//我们单单看「子串」的末位s[i]，它要么是左括号，要么是右括号：
s[i]是'('，左括号作为末尾字符，以它为结尾的子串不是有效括号子串——dp[i] = 0
s[i]是')'，我们考察前一个子问题的末尾：s[i-1]
s[i-1]是'('，它们俩结成一对( )，考察s[i-2]
s[i-2]不存在，这一对落单，有效长度为 2——dp[i] = 2
存在，考虑它们俩的前面提供的有效长度 dp[i] = dp[i-2] + 2
s[i-1]是')'，即'))'形式，这就来到子问题了，以s[i-1]为结尾形成的最长有效长度为dp[i-1]，跨过这个长度（里面细节不用管，总之它最大能提供dp[i-1]长度），来看s[i-dp[i-1]-1]这个字符
s[i-dp[i-1]-1]不存在或为')'，s[i]找不到匹配，直接gg，dp[i] = 0
s[i-dp[i-1]-1]是'('，它和s[i]遥相呼应，有效长度 2 保底！加上跨过的dp[i-1]，再加上前方的dp[i-dp[i-1]-2]…等等…s[i-dp[i-1]-2]要存在才行！
s[i-dp[i-1]-2]存在，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2
s[i-dp[i-1]-2]不存在，dp[i] = dp[i-1] + 2
base case ：dp[0] = 0 一个括号形成不了有效子串


class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.empty()) return 0;
        vector<int> dp(s.size(),0);
        dp[0]=0;//一个括号无法匹配的
        int ret=0;
        for(int i=1;i<s.size();i++)
        {
            if(s[i]==')') //只要是‘（’为i的子串，不可能为有效的括号
            {
                //正好和前一个'('匹配
                if(s[i-1]=='(')
                {
                    if(i-2>=0) //在前面的基础上加上有效的两个长度
                        dp[i]=dp[i-2]+2;
                    else
                        dp[i]=2;//前面没基础，'()'
                }
                else if (i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]=='(') //是相同的，就和i-dp[i-1]+1这一位看是否匹配，匹配则前后加一 ,且还要把之前的串起来 
                {
                    if(i-dp[i-1]-2>=0)
                    {
                        dp[i]=dp[i-1]+2+ dp[i-dp[i-1]-2]; //加上两个再把之前的串起来
                    }
                    else//没得串
                        dp[i]=dp[i-1]+2;
                }  
                ret=max(ret,dp[i]); 
            }
        }
        return ret;
    }
};
